diff --git a/cmd/client.go b/cmd/client.go index 9a937b3..7eab545 100644 --- a/cmd/client.go +++ b/cmd/client.go @@ -18,16 +18,6 @@ func NewClientCommand() cli.Command {
 				Usage: "the folder containing input files", EnvVar: "LLCONF_INPUT_FOLDER",
 			},
- cli.BoolFlag{ - Name: "syslog, s", - Usage: "output to syslog", - EnvVar: "LLCONF_SYSLOG", - }, - cli.StringFlag{ - Name: "runlog-path, r", - Usage: "path to the runlog", - EnvVar: "LLCONF_RUNLOG", 
- },
 			cli.StringFlag{
 				Name: "promise, p", Usage: "the root promise name", @@ -122,13 +112,13 @@ func NewClientCommand() cli.Command {
 				},
 			},
 			{ - Name: "servercert", + Name: "cert",
 				Subcommands: []cli.Command{
 					{
 						Name: "add", Flags: []cli.Flag{
 							cli.StringFlag{ - Name: "server-id", + Name: "id",
 								Usage: "the server-id the cert belongs to",
 							},
 							cli.StringFlag{ @@ -137,15 +127,15 @@ func NewClientCommand() cli.Command {
 							},
 						},
 						Action: func(ctx *cli.Context) error { - rCtx, err := context.New(ctx, false) + rCtx, err := context.New(ctx, true)
 							if err != nil {
 								return errors.Annotate(err, "new run context")
 							}
 							defer rCtx.Close()
 
- serverID := ctx.String("server-id") + serverID := ctx.String("id")
 							path := ctx.String("path") - if err := rCtx.AddServerCert(serverID, path); err != nil { + if err := rCtx.AddCert(serverID, path); err != nil {
 								return errors.Annotate(err, "add server cert")
 							}
 
@@ -157,19 +147,19 @@ func NewClientCommand() cli.Command {
 						Name: "rm", Flags: []cli.Flag{
 							cli.StringFlag{ - Name: "server-id", + Name: "id",
 								Usage: "the server-id the cert belongs to",
 							},
 						},
 						Action: func(ctx *cli.Context) error { - rCtx, err := context.New(ctx, false) + rCtx, err := context.New(ctx, true)
 							if err != nil {
 								return errors.Annotate(err, "new run context")
 							}
 							defer rCtx.Close()
 
- serverID := ctx.String("server-id") - if err := rCtx.RemoveServerCert(serverID); err != nil { + serverID := ctx.String("id") + if err := rCtx.RemoveCert(serverID); err != nil {
 								return errors.Annotate(err, "remove server cert")
 							}
 
diff --git a/cmd/server.go b/cmd/server.go index aafe3eb..3bafade 100644 --- a/cmd/server.go +++ b/cmd/server.go @@ -8,21 +8,8 @@ import (
 )
 
 func NewServerCommand() cli.Command { -
 	return cli.Command{
 		Name: "server", - Flags: []cli.Flag{ - cli.StringFlag{ - Name: "runlog-path, r", - Usage: "path to runlog", - EnvVar: "LLCONF_RUNLOG", - }, - cli.BoolFlag{ - Name: "syslog, s", - 
Usage: "output to syslog", - EnvVar: "LLCONF_SYSLOG", - }, - },
 		Subcommands: []cli.Command{
 			{
 				Name: "run", @@ -31,6 +18,7 @@ func NewServerCommand() cli.Command {
 					if err != nil {
 						return errors.Annotate(err, "new run context")
 					}
+ defer rCtx.Close()
 
 					if err := rCtx.CreateServer(); err != nil {
 						return errors.Annotate(err, "create server") @@ -40,13 +28,13 @@ func NewServerCommand() cli.Command {
 				},
 			},
 			{ - Name: "clientcert", + Name: "cert",
 				Subcommands: []cli.Command{
 					{
 						Name: "add", Flags: []cli.Flag{
 							cli.StringFlag{ - Name: "client-id", + Name: "id",
 								Usage: "the client-id the cert belongs to",
 							},
 							cli.StringFlag{ @@ -61,9 +49,9 @@ func NewServerCommand() cli.Command {
 							}
 							defer rCtx.Close()
 
- clientID := ctx.String("client-id") + clientID := ctx.String("id")
 							path := ctx.String("path") - if err := rCtx.AddClientCert(clientID, path); err != nil { + if err := rCtx.AddCert(clientID, path); err != nil {
 								return errors.Annotate(err, "register client cert")
 							}
 
@@ -75,7 +63,7 @@ func NewServerCommand() cli.Command {
 						Name: "rm", Flags: []cli.Flag{
 							cli.StringFlag{ - Name: "client-id", + Name: "id",
 								Usage: "the client-id the cert belongs to",
 							},
 						},
@@ -86,8 +74,8 @@ func NewServerCommand() cli.Command {
 							}
 							defer rCtx.Close()
 
- clientID := ctx.String("client-id") - if err := rCtx.RemoveClientCert(clientID); err != nil { + clientID := ctx.String("id") + if err := rCtx.RemoveCert(clientID); err != nil {
 								return errors.Annotate(err, "remove client cert")
 							}
 
diff --git a/context/context.go b/context/context.go index dd3a689..9909282 100644 --- a/context/context.go +++ b/context/context.go @@ -47,29 +47,30 @@ type RemoteCommand struct {
 ////////////////////////////////////////////////////////////////////////////////// type context struct {
 	Verbose bool - UseSyslog bool + useSyslog bool Interval int - Port int - RootPromise string - InputDir string - WorkDir string - RunlogPath string - Host string - SettingsDir string - 
DataStore *store.DataStore - ClientPrivKeyPath string - ClientCertFilePath string - ServerPrivKeyPath string - ServerCertFilePath string - AppCtx *cli.Context - Sender libchan.Sender - Receiver 
libchan.Receiver - RemoteSender libchan.Sender + port int + rootPromise string + inputDir string + workDir string + runlogPath string + host string + settingsDir string + dataStore *store.DataStore + 
clientPrivKeyPath string + clientCertFilePath string + serverPrivKeyPath string + serverCertFilePath string + certRole string + appCtx *cli.Context + sender libchan.Sender + receiver libchan.Receiver 
+ remoteSender libchan.Sender
 }
 
 ////////////////////////////////////////////////////////////////////////////////// func New(ctx *cli.Context, isClient bool) (*context, error) { -	rCtx := context{AppCtx: ctx} +	rCtx := 
context{appCtx: ctx}
 	err := rCtx.parseArguments(isClient) if err == nil {
 		go rCtx.signalHandler() @@ -82,8 +83,8 @@ func New(ctx *cli.Context, isClient bool) (*context, error) { func (p *context) Close() error { logging.Logger.Debug("close context")
 
- if p.DataStore != nil { - err := p.DataStore.Close() + if p.dataStore != nil { + err := p.dataStore.Close()
 		if err == nil {
 			logging.Logger.Info("datastore closed")
 		}
@@ -108,7 +109,7 @@ func (p *context) signalHandler() {
 
 ////////////////////////////////////////////////////////////////////////////////// func (p *context) upgradeLogging() error { -	if p.UseSyslog { +	if p.useSyslog {
 		hook, err := syslogger.NewSyslogHook("", "", syslog.LOG_INFO, "") if err != nil {
 			return err @@ -122,24 +123,24 @@ func (p *context) upgradeLogging() error {
 
 ////////////////////////////////////////////////////////////////////////////////// func (p *context) ensureClientCert() error { - if fileExists(p.ClientPrivKeyPath) && - 
fileExists(p.ClientCertFilePath) { + if fileExists(p.clientPrivKeyPath) && + fileExists(p.clientCertFilePath) {
 		return nil
 	}
 
 	logging.Logger.Info("create client certificates") -	return p.generateCert(p.ClientPrivKeyPath, p.ClientCertFilePath) +	return p.generateCert(p.clientPrivKeyPath, p.clientCertFilePath)
 }
 
 ////////////////////////////////////////////////////////////////////////////////// func (p *context) ensureServerCert() error { - if fileExists(p.ServerPrivKeyPath) && - 
fileExists(p.ServerCertFilePath) { + if fileExists(p.serverPrivKeyPath) && + fileExists(p.serverCertFilePath) {
 		return nil
 	}
 
 	logging.Logger.Info("create server certificates") -	return p.generateCert(p.ServerPrivKeyPath, p.ServerCertFilePath) +	return p.generateCert(p.serverPrivKeyPath, p.serverCertFilePath)
 }
 
 ////////////////////////////////////////////////////////////////////////////////// @@ -213,7 +214,7 @@ func (p *context) CreateServer() error {
 		return errors.Annotate(err, "load server cert")
 	}
 
-	srv := server.New(p.Host, p.Port, p.DataStore) +	srv := server.New(p.host, p.port, p.dataStore)
 	srv.OnPromiseReceived = p.ExecPromise
 
 	if err := srv.ListenAndRun(cert); err != nil { @@ -225,14 +226,14 @@ func (p *context) CreateServer() error {
 
 ////////////////////////////////////////////////////////////////////////////////// func (p *context) loadServerCert() (*tls.Certificate, error) { -	if _, err := os.Stat(p.ServerCertFilePath); 
os.IsNotExist(err) { +	if _, err := os.Stat(p.serverCertFilePath); os.IsNotExist(err) {
 		return nil, errors.New("tls cert file not found")
 	}
-	if _, err := os.Stat(p.ServerPrivKeyPath); os.IsNotExist(err) { +	if _, err := os.Stat(p.serverPrivKeyPath); os.IsNotExist(err) {
 		return nil, errors.New("tls privkey file not found")
 	}
 
-	tlsCert, err := tls.LoadX509KeyPair(p.ServerCertFilePath, p.ServerPrivKeyPath) +	tlsCert, err := tls.LoadX509KeyPair(p.serverCertFilePath, p.serverPrivKeyPath)
 	if err != nil {
 		return nil, errors.Annotate(err, "load key pair")
 	}
@@ -242,14 +243,14 @@ func (p *context) loadServerCert() (*tls.Certificate, error) {
 
 ////////////////////////////////////////////////////////////////////////////////// func (p *context) loadClientCert() (*tls.Certificate, error) { -	if _, err := os.Stat(p.ClientCertFilePath); 
os.IsNotExist(err) { +	if _, err := os.Stat(p.clientCertFilePath); os.IsNotExist(err) {
 		return nil, errors.New("tls cert file not found")
 	}
-	if _, err := os.Stat(p.ClientPrivKeyPath); os.IsNotExist(err) { +	if _, err := os.Stat(p.clientPrivKeyPath); os.IsNotExist(err) {
 		return nil, errors.New("tls privkey file not found")
 	}
 
-	tlsCert, err := tls.LoadX509KeyPair(p.ClientCertFilePath, p.ClientPrivKeyPath) +	tlsCert, err := tls.LoadX509KeyPair(p.clientCertFilePath, p.clientPrivKeyPath)
 	if err != nil {
 		return nil, errors.Annotate(err, "load key pair")
 	}
@@ -264,7 +265,7 @@ func (p *context) CreateClient() error {
 		return errors.Annotate(err, "load client cert")
 	}
 
-	pool, err := p.DataStore.ServerCertPool() +	pool, err := p.dataStore.Pool()
 	if err != nil {
 		return errors.Annotate(err, "get server cert pool")
 	}
@@ -275,7 +276,7 @@ func (p *context) CreateClient() error {
 	}
 
 	tlsConfig.BuildNameToCertificate() -	hostPort := net.JoinHostPort(p.Host, fmt.Sprintf("%d", p.Port)) +	hostPort := net.JoinHostPort(p.host, fmt.Sprintf("%d", p.port))
 
 	conn, err := tls.Dial("tcp", hostPort, &tlsConfig)
 
@@ -294,8 +295,8 @@ func (p *context) CreateClient() error {
 		return errors.Annotate(err, "new send channel")
 	}
 
-	p.Sender = snd -	p.Receiver, p.RemoteSender = libchan.Pipe() +	p.sender = snd +	p.receiver, p.remoteSender = libchan.Pipe()
 	return nil
 }
 
@@ -303,14 +304,14 @@ func (p *context) CreateClient() error {
 func (p *context) CompilePromise() (promise.Promise, error) {
 	logging.Logger.Info("compile promise")
 
-	promises, err := compiler.Compile(p.InputDir) +	promises, err := compiler.Compile(p.inputDir)
 	if err != nil {
 		return nil, errors.Annotate(err, "compile promise")
 	}
 
-	tree, ok := promises[p.RootPromise] +	tree, ok := promises[p.rootPromise]
 	if !ok { - return nil, errors.New("root promise (" + p.RootPromise + ") unknown") + return nil, errors.New("root promise (" + p.rootPromise + ") unknown")
 	}
 
 	return tree, nil @@ -323,31 +324,31 @@ func (p *context) parseArguments(isClient bool) error { if err != nil {
 		return errors.Annotate(err, "get wd")
 	}
-	p.WorkDir = wd +	p.workDir = wd
 
 	if isClient { - p.InputDir = p.AppCtx.String("input-folder") - if p.InputDir == "" { - p.InputDir = filepath.Join(p.WorkDir, "input") + p.inputDir = p.appCtx.String("input-folder") + if 
p.inputDir == "" { + p.inputDir = filepath.Join(p.workDir, "input")
 		}
- if err := os.MkdirAll(p.InputDir, 0755); err != nil { + if err := os.MkdirAll(p.inputDir, 0755); err != nil {
 			return errors.Annotate(err, "create input dir")
 		}
 	}
 
- p.RunlogPath = p.AppCtx.String("runlog-path") - if p.RunlogPath == "" { - p.RunlogPath = filepath.Join(p.WorkDir, "run.log") + p.runlogPath = p.appCtx.GlobalString("runlog-path") + if p.runlogPath 
== "" { + p.runlogPath = filepath.Join(p.workDir, "run.log")
 	}
 
-	logging.SetDebug(p.AppCtx.GlobalBool("debug")) -	p.RootPromise = p.AppCtx.GlobalString("promise") -	p.Verbose = p.AppCtx.GlobalBool("verbose") -	p.Host = 
p.AppCtx.GlobalString("host") -	p.Port = p.AppCtx.GlobalInt("port") -	p.Interval = p.AppCtx.Int("interval") +	logging.SetDebug(p.appCtx.GlobalBool("debug")) +	p.rootPromise = 
p.appCtx.GlobalString("promise") +	p.Verbose = p.appCtx.GlobalBool("verbose") +	p.host = p.appCtx.GlobalString("host") +	p.port = p.appCtx.GlobalInt("port") +	p.Interval = 
p.appCtx.Int("interval")
 
-	p.UseSyslog = p.AppCtx.Bool("syslog") +	p.useSyslog = p.appCtx.GlobalBool("syslog")
 	if err := p.upgradeLogging(); err != nil {
 		return errors.Annotate(err, "upgrade logging")
 	}
@@ -357,8 +358,8 @@ func (p *context) parseArguments(isClient bool) error {
 		return errors.Annotate(err, "get current user")
 	}
 
-	p.SettingsDir = path.Join(usr.HomeDir, "/.llconf") -	if err := os.MkdirAll(p.SettingsDir, 0755); err != nil { +	p.settingsDir = path.Join(usr.HomeDir, "/.llconf") +	if err := 
os.MkdirAll(p.settingsDir, 0755); err != nil {
 		return errors.Annotate(err, "create settings dir")
 	}
 
@@ -367,34 +368,42 @@ func (p *context) parseArguments(isClient bool) error {
 		return errors.Annotate(err, "create cert dir")
 	}
 
+ dataStorePath := path.Join(usr.HomeDir, "/.llconf/store") + if err := os.MkdirAll(dataStorePath, 0700); err != nil { + return errors.Annotate(err, "create datastore dir") +	} +
 	if isClient { - p.ClientPrivKeyPath = path.Join(certDir, "client.privkey.pem") - p.ClientCertFilePath = path.Join(certDir, "client.cert.pem") + p.clientPrivKeyPath = path.Join(certDir, 
"client.privkey.pem") + p.clientCertFilePath = path.Join(certDir, "client.cert.pem")
 		if err := p.ensureClientCert(); err != nil {
 			return errors.Annotate(err, "ensure client cert")
 		}
+ + p.certRole = "server" + store, err := store.New("client", p.certRole, dataStorePath) + if err != nil { + return errors.Annotate(err, "create data store") + } + p.dataStore = store
 	} else {
- p.ServerPrivKeyPath = path.Join(certDir, "server.privkey.pem") - p.ServerCertFilePath = path.Join(certDir, "server.cert.pem") + p.serverPrivKeyPath = path.Join(certDir, "server.privkey.pem") + 
p.serverCertFilePath = path.Join(certDir, "server.cert.pem")
 		if err := p.ensureServerCert(); err != nil {
 			return errors.Annotate(err, "ensure server cert")
 		}
-	}
 
- dataStorePath := path.Join(usr.HomeDir, "/.llconf/store") - if err := os.MkdirAll(dataStorePath, 0700); err != nil { - return errors.Annotate(err, "create datastore dir") - } - - store, err := 
store.New(dataStorePath) - if err != nil { - return errors.Annotate(err, "create data store") + p.certRole = "client" + store, err := store.New("server", p.certRole, dataStorePath) + if err != nil { + 
return errors.Annotate(err, "create data store") + } + p.dataStore = store
 	}
-	p.DataStore = store
 
 	// when run as daemon, the home folder isn't set if os.Getenv("HOME") == "" { - os.Setenv("HOME", p.WorkDir) + os.Setenv("HOME", p.workDir)
 	}
 
 	gob.Register(promise.NamedPromise{}) @@ -411,63 +420,33 @@ func (p *context) parseArguments(isClient bool) error {
 }
 
 ////////////////////////////////////////////////////////////////////////////////// -func (p *context) AddClientCert(clientID string, certPath string) error { - logging.Logger.Info("server: add client 
cert") - - if clientID == "" { - return errors.New("no client id provided") - } - - if certPath == "" { - return errors.New("no client certificate path provided") - } - - if !fileExists(certPath) { - 
return errors.New("client certificate file does not exist") - } - - return p.DataStore.StoreClientCert(clientID, certPath) -} - 
-////////////////////////////////////////////////////////////////////////////////// -func (p *context) RemoveClientCert(clientID string) error { - logging.Logger.Info("server: remove client cert") - - 
if clientID == "" { - return errors.New("no client id provided") -	} - -	return p.DataStore.RemoveClientCert(clientID) -} - 
-////////////////////////////////////////////////////////////////////////////////// -func (p *context) AddServerCert(serverID string, certPath string) error { -	logging.Logger.Info("client: add 
server cert") +func (p *context) AddCert(id string, certPath string) error { +	logging.Logger.Infof("add %s cert", p.certRole)
 
- if serverID == "" { - return errors.New("no server id provided") + if id == "" { + return errors.Errorf("no %s id provided", p.certRole)
 	}
 
 	if certPath == "" { - return errors.New("no server certificate path provided") + return errors.Errorf("no %s certificate path provided", p.certRole)
 	}
 
 	if !fileExists(certPath) { - return errors.New("server certificate file does not exist") + return errors.Errorf("%s certificate file does not exist", p.certRole)
 	}
 
-	return p.DataStore.StoreServerCert(serverID, certPath) +	return p.dataStore.StoreCert(id, certPath)
 }
 
 ////////////////////////////////////////////////////////////////////////////////// -func (p *context) RemoveServerCert(serverID string) error { -	logging.Logger.Info("client: remove server 
cert") +func (p *context) RemoveCert(id string) error { +	logging.Logger.Infof("remove %s cert", p.certRole)
 
- if serverID == "" { - return errors.New("no server id provided") + if id == "" { + return errors.Errorf("no %s id provided", p.certRole)
 	}
 
-	return p.DataStore.RemoveServerCert(serverID) +	return p.dataStore.RemoveCert(id)
 }
 
 ////////////////////////////////////////////////////////////////////////////////// @@ -482,21 +461,21 @@ func (p *context) SendPromise(tree promise.Promise) error {
 	cmd := RemoteCommand{
 		Data: buf.Bytes(), Stdout: os.Stdout, - SendChannel: p.RemoteSender, + SendChannel: p.remoteSender, Verbose: p.Verbose,
 	}
 
 	logging.Logger.Info("send promise") -	if err := p.Sender.Send(cmd); err != nil { +	if err := p.sender.Send(cmd); err != nil {
 		return errors.Annotate(err, "send")
 	}
 
-	if err := p.Sender.Close(); err != nil { +	if err := p.sender.Close(); err != nil {
 		return errors.Annotate(err, "close sender channel")
 	}
 
 	resp := server.CommandResponse{} -	if err := p.Receiver.Receive(&resp); err != nil { +	if err := p.receiver.Receive(&resp); err != nil {
 		return errors.Annotate(err, "receive")
 	}
 
@@ -507,14 +486,14 @@ func (p *context) SendPromise(tree promise.Promise) error {
 ////////////////////////////////////////////////////////////////////////////////// func (p *context) ExecPromise(tree promise.Promise, verbose bool) error {
 	vars := promise.Variables{} -	vars["input_dir"] = p.InputDir -	vars["work_dir"] = p.WorkDir +	vars["input_dir"] = p.inputDir +	vars["work_dir"] = p.workDir vars["executable"] 
 	= filepath.Clean(os.Args[0])
 
 	ctx := promise.Context{
 		ExecOutput: &bytes.Buffer{}, Vars: vars, - Args: p.AppCtx.Args(), + Args: p.appCtx.Args(), Env: []string{}, Verbose: verbose, InDir: "", @@ -528,7 +507,7 @@ func (p *context) 
ExecPromise(tree promise.Promise, verbose bool) error {
 	logging.Logger.Infof("%d changes and %d tests executed in %s",
 		logging.Logger.Changes, logging.Logger.Tests, endtime.Sub(starttime))
 
-	writeRunLog(err, starttime, endtime, p.RunlogPath) +	writeRunLog(err, starttime, endtime, p.runlogPath)
 	return err
 }
 
diff --git a/main.go b/main.go index 5dec8cf..cabcf78 100644 --- a/main.go +++ b/main.go @@ -25,7 +25,6 @@ func main() {
 			EnvVar: "LLCONF_PORT", Value: 9954,
 		},
-
 		cli.BoolFlag{
 			Name: "verbose", Usage: "enable verbose output", @@ -36,6 +35,16 @@ func main() { Usage: "enable debug output", EnvVar: "LLCONF_DEBUG",
 		},
+ cli.StringFlag{ + Name: "runlog-path, r", + Usage: "path to runlog", + EnvVar: "LLCONF_RUNLOG", + }, + cli.BoolFlag{ + Name: "syslog, s", + Usage: "output to syslog", + EnvVar: "LLCONF_SYSLOG", + },
 	}
 
 	app.Commands = []cli.Command{ diff --git a/samples/test/input/git.cnf b/samples/test/input/git.cnf index a43b4c6..bea84e5 100644 --- a/samples/test/input/git.cnf +++ 
b/samples/test/input/git.cnf @@ -10,9 +10,9 @@
 )
 
 (git configured - (and (change "git" "config" "--global" "user.name" "peristaltic") - (change "git" "config" "--global" "user.email" "peristaltic@gmx.net") - (change "git" "config" "--global" 
"push.default" "simple") - (change "git" "config" "--global" "core.excludesfile" "~/.gitignore") + (and + (change "git" "config" "--global" "user.name" "peristaltic") + (change "git" "config" 
"--global" "user.email" "peristaltic@gmx.net") + (change "git" "config" "--global" "core.excludesfile" "~/.gitignore")
     ) ) diff --git a/samples/test/input/lib/installer.cnf b/samples/test/input/lib/installer.cnf index 4cfb7d7..53733fa 100644 --- a/samples/test/input/lib/installer.cnf +++ 
b/samples/test/input/lib/installer.cnf @@ -1,26 +1,58 @@ +
 (installed - (or - (is package present [arg:0]) - (change "sudo" "apt-get" "--force-yes" "--yes" "install" [arg:0]) - ) + (and + (is debian) + (or + (debian is package present [arg:0]) + (change 
"sudo" "apt-get" "--force-yes" "--yes" "install" [arg:0]) + ) + )
 )
 
 (uninstalled - (or - (is package absent [arg:0]) - (change "sudo" "apt-get" "--yes" "purge" [arg:0]) + (and + (is debian) + (or + (debian is package absent [arg:0]) + (change "sudo" "apt-get" "--yes" 
"purge" [arg:0]) + )
 	) )
 
-(is package absent +(debian is package absent
 	(not - (is package present [arg:0]) + (debian is package present [arg:0]) + ) +) + +(debian is package present + (and + (is debian) + (pipe + (test "dpkg-query" "-W" 
"--showformat='${Status}\n'" [arg:0]) + (test "grep" "install ok installed") + ) + ) +) + +(yum installed + (or + (yum package present) + (yum install package)) + ) + +(yum package present + (pipe + 
(test "yum" "--quiet" "list" "installed") + (test "sed" "-rn" "s/([^.]+).*/\1/p") + (test "grep" [arg:0])
 	) )
 
-(is package present - (pipe - (test "dpkg-query" "-W" "--showformat='${Status}\n'" [arg:0]) - (test "grep" "install ok installed") - ) +(yum install package + (change "yum" "install" [arg:0]) +) + 
+(rpm install package + (change "rpm" "-ihv" [arg:0])
 ) \ No newline at end of file diff --git a/samples/test/input/lib/system.cnf b/samples/test/input/lib/system.cnf index f7541c1..7191885 100644 --- a/samples/test/input/lib/system.cnf +++ 
b/samples/test/input/lib/system.cnf @@ -8,9 +8,30 @@
 
 (system update
     (and + (is debian)
         (change "sudo" "apt-get" "update") (change "sudo" "apt-get" "--yes" "upgrade") (change "sudo" "apt-get" "--yes" "dist-upgrade")
 		(change "sudo" "apt-get" "--yes" "autoclean") ) +) + +(is debian + (or + (pipe + (test "uname" "-v") + (test "grep" "Debian") + ) + (pipe + (test "uname" "-v") + (test "grep" "Ubuntu") 
+ ) + ) +) + +(is fedora + (pipe + (test "uname" "-v") + (test "grep" "Fedora") +	)
 ) \ No newline at end of file diff --git a/samples/test/input/main.cnf b/samples/test/input/main.cnf index be02b9a..9db37de 100644 --- a/samples/test/input/main.cnf +++ b/samples/test/input/main.cnf 
@@ -2,10 +2,8 @@
 	(and
 		(installed "htop") (installed "wget") - (ensure hostname "v777") - (change "echo" "hallo denkhaus!") + (ensure hostname "v999") (ssh ready) - (ensure user absent "willy") - + (system 
update)
 	) ) diff --git a/server/server.go b/server/server.go index ed67956..dfc318d 100644 --- a/server/server.go +++ b/server/server.go @@ -54,7 +54,7 @@ func New(host string, port int, ds 
*store.DataStore) *Server {
 
 ////////////////////////////////////////////////////////////////////////////////// func (p *Server) ListenAndRun(cert *tls.Certificate) error { -	pool, err := p.DataStore.ClientCertPool() +	
pool, err := p.DataStore.Pool()
 	if err != nil {
 		return errors.Annotate(err, "get client cert pool")
 	}
@@ -63,14 +63,12 @@ func (p *Server) ListenAndRun(cert *tls.Certificate) error {
 		Certificates: []tls.Certificate{*cert}, // Reject any TLS certificate that cannot be validated ClientAuth: tls.RequireAndVerifyClientCert, - // Ensure that we only use our "CA" to 
 		validate certificates ClientCAs: pool, CipherSuites: []uint16{
 			tls.TLS_RSA_WITH_AES_256_GCM_SHA384, tls.TLS_RSA_WITH_AES_256_CBC_SHA,
 		},
-
 		// Force it server side PreferServerCipherSuites: true, // TLS 1.2 because we can diff --git a/store/datastore.go b/store/datastore.go index 6ef77f1..b26557f 100644 --- 
a/store/datastore.go +++ b/store/datastore.go @@ -19,30 +19,26 @@ type CertEntry struct {
 
 //////////////////////////////////////////////////////////////////////////////// type DataStore struct { - db *bolt.DB - clientCS *stow.Store - serverCS *stow.Store + db *bolt.DB + role string + 
certStore *stow.Store + serverCS *stow.Store
 }
 
 //////////////////////////////////////////////////////////////////////////////// -var ( -	ErrNotFound = fmt.Errorf("Datastore:: value not found") -) +func New(id, role, storePath string) 
(*DataStore, error) {
 
-//////////////////////////////////////////////////////////////////////////////// -func New(storePath string) (*DataStore, error) { -	db, err := bolt.Open(path.Join(storePath, "store.db"), 0600, 
nil) +	storePath = path.Join(storePath, fmt.Sprintf("%s.store.db", id)) +	db, err := bolt.Open(storePath, 0600, nil)
 	if err != nil {
 		return nil, err
 	}
 
-	clientCertStore := stow.NewStore(db, []byte("client-certs")) -	serverCertStore := stow.NewStore(db, []byte("server-certs")) - +	certStore := stow.NewStore(db, []byte("certs"))
 	store := &DataStore{ - db: db, - clientCS: clientCertStore, - serverCS: serverCertStore, + db: db, + role: role, + certStore: certStore,
 	}
 
 	return store, nil @@ -60,32 +56,12 @@ func (d *DataStore) Close() error {
 }
 
 //////////////////////////////////////////////////////////////////////////////// -func (d *DataStore) ClientCertPool() (*x509.CertPool, error) { - pool := x509.NewCertPool() - - err := 
d.clientCS.ForEach(func(clientID string, entry CertEntry) { - if ok := pool.AppendCertsFromPEM(entry.Data); !ok { - logging.Logger.Errorf("unable to add client certificate for id %q to pool", 
clientID) - } - }) - if err != nil { - return nil, errors.Annotate(err, "enumerate cert entries") - } - - if len(pool.Subjects()) == 0 { - return nil, errors.New("no client certificates stored") -	
}
- -	return pool, nil -} - -//////////////////////////////////////////////////////////////////////////////// -func (d *DataStore) ServerCertPool() (*x509.CertPool, error) { +func (d *DataStore) 
Pool() (*x509.CertPool, error) {
 	pool := x509.NewCertPool()
 
-	err := d.serverCS.ForEach(func(serverID string, entry CertEntry) { +	err := d.certStore.ForEach(func(id string, entry CertEntry) {
 		if ok := pool.AppendCertsFromPEM(entry.Data); !ok { - logging.Logger.Errorf("unable to add server certificate for id %q to pool", serverID) + logging.Logger.Errorf("unable to add %s 
certificate for id %q to pool", d.role, id)
 		}
 	})
 	if err != nil { @@ -93,67 +69,36 @@ func (d *DataStore) ServerCertPool() (*x509.CertPool, error) {
 	}
 
 	if len(pool.Subjects()) == 0 { - return nil, errors.New("no server certificates stored") + return nil, errors.Errorf("no %s certificates stored", d.role)
 	}
 
 	return pool, nil
 }
 
 //////////////////////////////////////////////////////////////////////////////// -func (d *DataStore) StoreClientCert(clientID string, certPath string) error { - data, err := 
ioutil.ReadFile(certPath) - if err != nil { - return errors.Annotate(err, "load client cert file") - } - entry := CertEntry{} - if err := d.clientCS.Get(clientID, &entry); err == nil { - return 
errors.Errorf("certificate for client id %q already stored", clientID) -	} - -	entry.Data = data -	return d.clientCS.Put(clientID, entry) -} - 
-//////////////////////////////////////////////////////////////////////////////// -func (d *DataStore) StoreServerCert(serverID string, certPath string) error { +func (d *DataStore) StoreCert(id 
string, certPath string) error {
 	data, err := ioutil.ReadFile(certPath) if err != nil { - return errors.Annotate(err, "load server cert file") + return errors.Annotatef(err, "load %s cert file", d.role)
 	}
 	entry := CertEntry{} - if err := d.serverCS.Get(serverID, &entry); err == nil { - return errors.Errorf("certificate for server id %q already stored", serverID) + if err := d.certStore.Get(id, 
&entry); err == nil { + return errors.Errorf("certificate for %s id %q already stored", d.role, id)
 	}
 
 	entry.Data = data - return d.serverCS.Put(serverID, entry) -} - -//////////////////////////////////////////////////////////////////////////////// -func (d *DataStore) RemoveClientCert(clientID 
string) error { - - entry := CertEntry{} - if err := d.clientCS.Get(clientID, &entry); err != nil { - return errors.Errorf("certificate for client id %q not available", clientID) -	} - -	if err 
:= d.clientCS.Delete(clientID); err != nil {
- return errors.Annotatef(err, "delete certificate for client id %q", clientID) -	} - -	return nil +	return d.certStore.Put(id, entry)
 }
 
 //////////////////////////////////////////////////////////////////////////////// -func (d *DataStore) RemoveServerCert(serverID string) error { - +func (d *DataStore) RemoveCert(id string) error {
 	entry := CertEntry{} - if err := d.serverCS.Get(serverID, &entry); err != nil { - return errors.Errorf("certificate for server id %q not available", serverID) + if err := d.certStore.Get(id, 
&entry); err != nil { + return errors.Errorf("certificate for %s id %q not available", d.role, id)
 	}
 
- if err := d.serverCS.Delete(serverID); err != nil { - return errors.Annotatef(err, "delete certificate for server id %q", serverID) + if err := d.certStore.Delete(id); err != nil { + return 
errors.Annotatef(err, "delete certificate for %s id %q", d.role, id)
 	}
 
 	return nil
